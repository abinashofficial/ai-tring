
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>app: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">aitring/app/app.go (0.0%)</option>
				
				<option value="file1">aitring/app/routes.go (0.0%)</option>
				
				<option value="file2">aitring/handlers/audios/store.go (0.0%)</option>
				
				<option value="file3">aitring/services/audios/impl.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package app

import (
        "aitring/handlers"
        "aitring/store"
        "aitring/services"
        audioHandler "aitring/handlers/audios"
        audioStore "aitring/store/audiostore"
        audioServ "aitring/services/audios"
        "log"
        "aitring/store/pipelinestore"
        "context"
            "runtime/debug" // &lt;-- for debug.Stack()

)

var h handlers.Store
var repos store.Store
var serv services.Store



func setupRepos() <span class="cov0" title="0">{
        cfg := pipelinestore.DefaultConfig()
        audStore := audioStore.NewAudioStore("metadata.json")
        repos = store.Store{
                AudioStore: audioStore.New(),
                PipelineStore: pipelinestore.New(cfg, audStore),
        }
}</span>

func setupHandlers() <span class="cov0" title="0">{
        h = handlers.Store{
                AudioHandler: audioHandler.New(serv),
        }
}</span>

func setupService() <span class="cov0" title="0">{
        serv = services.Store{
                AudioServ: audioServ.New(repos),
        }
}</span>

func safeGo(fn func()) <span class="cov0" title="0">{
    go func() </span><span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
            if r := recover(); r != nil </span><span class="cov0" title="0">{
                log.Printf("[PANIC] in %s: %v\n%s", "pipeline workers", r, debug.Stack())
            }</span>
        }()
        <span class="cov0" title="0">fn()</span>
    }()
}


func Start() <span class="cov0" title="0">{
                log.SetFlags(log.LstdFlags | log.Lmicroseconds)
        
        setupRepos()
        setupService()
        setupHandlers()
        ctx, cancel := context.WithCancel(context.Background())
        defer cancel()
        safeGo( func() </span><span class="cov0" title="0">{
                repos.PipelineStore.Start(ctx)
        }</span>)
        <span class="cov0" title="0">envPort := "8080"

        runServer(envPort, h)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "aitring/handlers"
        "fmt"
        "log"
        "net/http"
        "aitring/model"

        "github.com/gorilla/mux"
)

// CORS middleware to set the headers
func enableCORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Allow requests from specific frontend origins
                w.Header().Set("Access-Control-Allow-Origin", "*") // Replace with your production client URL

                // Allow specific methods (GET, POST, OPTIONS, etc.)
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")

                // Allow specific headers
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

                // Handle preflight OPTIONS requests
                if r.Method == http.MethodOptions </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func runServer(envPort string, h handlers.Store) <span class="cov0" title="0">{

        // Ensure envPort has a valid default value
        if envPort == "" </span><span class="cov0" title="0">{
                envPort = "8080"
        }</span>

        // Create a new router
        <span class="cov0" title="0">r := mux.NewRouter()

        // Public routes

        r.HandleFunc("/public/chunks/{id}", h.AudioHandler.GetChunkByID).Methods(http.MethodGet)

        r.HandleFunc("/public/sessions/{user_id}", h.AudioHandler.GetChunksByUser).Methods(http.MethodGet)

        r.HandleFunc("/public/upload", h.AudioHandler.Upload).Methods(http.MethodPost)



        // WebSocket route
        r.HandleFunc("/ws", h.AudioHandler.WSHandler).Methods(http.MethodGet)

                // metrics endpoint (simple text)
        r.HandleFunc("/metrics", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "ingested %d\nvalidated %d\ntransformed %d\nstored %d\nrejected %d\ndropped %d\n",
                        model.MetricsIngested.Get(), model.MetricsValidated.Get(), model.MetricsTransformed.Get(), model.MetricsStored.Get(), model.MetricsRejected.Get(), model.MetricsDropped.Get(),
                )
        }</span>)

        //    r.HandleFunc("/events",h.FieldsHandler.SSEHandler)

        // Wrap the router with CORS middleware
        <span class="cov0" title="0">http.Handle("/", enableCORS(r))

        // Start the server
        fmt.Printf("Server listening on port %s...\n", envPort)
        log.Fatal(http.ListenAndServe(":"+envPort, nil))</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package audios

import (
        "aitring/model"
        "aitring/services"
        AudioServ "aitring/services/audios"
        "aitring/utils"
        "io"
        "net/http"
        "time"
        "github.com/google/uuid"
        "github.com/gorilla/mux"
        "github.com/gorilla/websocket"
        "encoding/json"
                "encoding/base64"

 "strings"

        "fmt"
        
)

func New(store services.Store) Handler <span class="cov0" title="0">{
        return &amp;audioHandler{
                audioService: store.AudioServ,
        }
}</span>

type audioHandler struct {
        audioService AudioServ.Service
          
}

var upgrader = websocket.Upgrader{
        CheckOrigin: func(r *http.Request) bool <span class="cov0" title="0">{
                // origin := r.Header.Get("Origin")
                // return origin == "http://localhost:3000" || origin == "https://tringai.com"
                      // Allow all origins (for dev)
        return true
        }</span>,
}

type UploadResponse struct {
    Status  string `json:"status"`
    ChunkID string `json:"chunk_id"`
}
func (h *audioHandler) Upload(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
    userID := r.FormValue("user_id")
    sessionID := r.FormValue("session_id")
    tsStr := r.FormValue("timestamp")

    if userID == "" || sessionID == "" </span><span class="cov0" title="0">{
        http.Error(w, "missing user_id or session_id", http.StatusBadRequest)
        return
    }</span>

    // Parse timestamp if provided, else use now
    <span class="cov0" title="0">ts := time.Now()
    if tsStr != "" </span><span class="cov0" title="0">{
        if parsed, err := time.Parse(time.RFC3339, tsStr); err == nil </span><span class="cov0" title="0">{
            ts = parsed
        }</span>
    }

    <span class="cov0" title="0">var data []byte
    // Detect multipart vs raw
    ct := strings.ToLower(r.Header.Get("Content-Type"))
    if strings.HasPrefix(ct, "multipart/form-data") </span><span class="cov0" title="0">{
        if err := r.ParseMultipartForm(25 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
            http.Error(w, "parse multipart failed", http.StatusBadRequest)
            return
        }</span>

        <span class="cov0" title="0">files := r.MultipartForm.File["files"]
        if len(files) == 0 </span><span class="cov0" title="0">{
            http.Error(w, "no files provided", http.StatusBadRequest)
            return
        }</span>

        <span class="cov0" title="0">var responses []UploadResponse
        for _, fileHeader := range files </span><span class="cov0" title="0">{
            file, err := fileHeader.Open()
            if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "open file failed", http.StatusBadRequest)
                return
            }</span>
            <span class="cov0" title="0">data, err := io.ReadAll(file)
            file.Close()
            if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "read file failed", http.StatusBadRequest)
                return
            }</span>

            <span class="cov0" title="0">chunkID := uuid.NewString()
            ackCh := make(chan model.ChunkMeta, 1)
            raw := model.RawChunk{
                ChunkID:   chunkID,
                SessionID: sessionID,
                UserID:    userID,
                Data:      data,
                Received:  ts,
                AckCh:     ackCh,
            }

            // Push into pipeline
            if ok, _ := h.audioService.UploadAudio(r.Context(), raw); !ok </span><span class="cov0" title="0">{
                http.Error(w, "pipeline backpressure: rejected", http.StatusTooManyRequests)
                return
            }</span>

            <span class="cov0" title="0">responses = append(responses, UploadResponse{
                Status:  "accepted",
                ChunkID: chunkID,
            })</span>
        }

        // Respond with all chunk IDs
        <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusAccepted)
        json.NewEncoder(w).Encode(responses)
        return</span>
    
    } else<span class="cov0" title="0"> {
        defer r.Body.Close()
        b, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
            http.Error(w, "read body failed", http.StatusBadRequest)
            return
        }</span>
        <span class="cov0" title="0">data = b</span>
    }

    // Create chunk
    <span class="cov0" title="0">chunkID := uuid.NewString()
    ackCh := make(chan model.ChunkMeta, 1)
    raw := model.RawChunk{
        ChunkID:   chunkID,
        SessionID: sessionID,
        UserID:    userID,
        Data:      data,
        Received:  ts,
        AckCh:     ackCh,
    }

        
    // Push into pipeline
    if ok, _ := h.audioService.UploadAudio(r.Context(), raw); !ok </span><span class="cov0" title="0">{
        http.Error(w, "pipeline backpressure: rejected", http.StatusTooManyRequests)
        return
    }</span>

    // Respond with 202 Accepted
    <span class="cov0" title="0">w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusAccepted)
    json.NewEncoder(w).Encode(UploadResponse{
        Status:  "accepted",
        ChunkID: chunkID,
    })</span>
}

func (h audioHandler) GetChunkByID(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := mux.Vars(r)["id"]
        meta, err := h.audioService.GetAudioMetadata(id)
        if err != nil </span><span class="cov0" title="0">{
                utils.ErrorResponse(w,"audio metadata not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">utils.ReturnResponse(w, http.StatusOK, meta)</span>
}

func (h audioHandler) GetChunksByUser(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        userID := mux.Vars(r)["user_id"]
        chunks, err := h.audioService.GetAudioChunks(userID)
        if err != nil </span><span class="cov0" title="0">{
                // http.Error(w, "failed to get audio chunks", http.StatusInternalServerError)
                utils.ErrorResponse(w,"audio metadata not found", http.StatusNotFound)
                return
        }</span>
        <span class="cov0" title="0">utils.ReturnResponse(w, http.StatusOK, chunks)</span>
}

func (h audioHandler) WSHandler(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
userID := r.URL.Query().Get("user_id")
        sessionID := r.URL.Query().Get("session_id")
        if userID == "" || sessionID == "" </span><span class="cov0" title="0">{ http.Error(w, "user_id &amp; session_id required", http.StatusBadRequest); return }</span>

        <span class="cov0" title="0">conn, err := upgrader.Upgrade(w, r, nil)
        if err != nil </span><span class="cov0" title="0">{ http.Error(w, "upgrade failed", http.StatusBadRequest); return }</span>
        <span class="cov0" title="0">defer conn.Close()

        for </span><span class="cov0" title="0">{
                mt, msg, err := conn.ReadMessage()
                if err != nil </span><span class="cov0" title="0">{ return }</span>

                // Support both binary frames and JSON text frames with base64
                <span class="cov0" title="0">var data []byte
                var ts = time.Now()
                if mt == websocket.BinaryMessage </span><span class="cov0" title="0">{
                        data = msg
                }</span> else<span class="cov0" title="0"> {
                        var payload struct {
                                AudioB64  string `json:"audio_b64"`
                                Timestamp string `json:"timestamp,omitempty"`
                        }
                        if err := json.Unmarshal(msg, &amp;payload); err != nil </span><span class="cov0" title="0">{
                                _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"error":"invalid json"}`))
                                continue</span>
                        }
                        <span class="cov0" title="0">if payload.Timestamp != "" </span><span class="cov0" title="0">{ if parsed, err := time.Parse(time.RFC3339, payload.Timestamp); err == nil </span><span class="cov0" title="0">{ ts = parsed }</span> }
                        <span class="cov0" title="0">if payload.AudioB64 == "" </span><span class="cov0" title="0">{
                                _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"error":"missing audio_b64"}`))
                                continue</span>
                        }
                        <span class="cov0" title="0">b, err := base64.StdEncoding.DecodeString(payload.AudioB64)
                        if err != nil </span><span class="cov0" title="0">{ _ = conn.WriteMessage(websocket.TextMessage, []byte(`{"error":"invalid base64"}`)); continue</span> }
                        <span class="cov0" title="0">data = b</span>
                }

                <span class="cov0" title="0">chunkID := uuid.NewString()
                ackCh := make(chan model.ChunkMeta, 1)
                raw := model.RawChunk{ChunkID: chunkID, SessionID: sessionID, UserID: userID, Data: data, Received: ts, AckCh: ackCh}
                ok, _ := h.audioService.UploadAudio(r.Context(), raw)

                // Immediate ack
                ack := map[string]any{"type": "ack", "chunk_id": chunkID, "accepted": ok}
                bAck, _ := json.Marshal(ack)
                _ = conn.WriteMessage(websocket.TextMessage, bAck)
                if !ok </span><span class="cov0" title="0">{ continue</span> }

                // Stream metadata when processed (or timeout)
                <span class="cov0" title="0">select </span>{
                case meta := &lt;-ackCh:<span class="cov0" title="0">
                        metaEv := map[string]any{"type": "metadata", "chunk_id": chunkID, "meta": meta}
                        b, _ := json.Marshal(metaEv)
                        _ = conn.WriteMessage(websocket.TextMessage, b)</span>
                case &lt;-time.After(5 * time.Second):<span class="cov0" title="0">
                        _ = conn.WriteMessage(websocket.TextMessage, []byte(fmt.Sprintf(`{"type":"metadata","chunk_id":"%s","status":"pending"}`, chunkID)))</span>
                }
}
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package audios

import (
        "aitring/model"
        "aitring/store"
        AudioStore "aitring/store/audiostore"
        "aitring/store/pipelinestore"
        "context"
)

func New(Store store.Store) Service <span class="cov10" title="4">{
        return &amp;audioService{
                audioRepo: Store.AudioStore,
                audioStore: Store.PipelineStore,
        }
}</span>

type audioService struct {
        audioRepo AudioStore.Repository
        audioStore pipelinestore.Repository
}


        func (s audioService) UploadAudio(ctx context.Context, raw model.RawChunk) (bool, error)<span class="cov1" title="1">{
                return s.audioStore.Ingest(ctx, raw)
        }</span>
        
        
        func (s audioService)GetAudioChunks(userID string) ([]model.ChunkMeta, error)<span class="cov5" title="2">{
                return s.audioStore.GetChunksByUser(userID)

        }</span>
        func (s audioService)GetAudioMetadata(chunkID string) (model.ChunkMeta, error)<span class="cov5" title="2">{
                return  s.audioStore.GetMetadata(chunkID)

        }</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
